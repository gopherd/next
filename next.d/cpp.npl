{{- define "next/cpp/file" -}}
#pragma once

{{next .Imports -}}
{{render "cpp/namespace.begin" . -}}
{{render "cpp/forward.declarations" . -}}
{{next .Specs -}}
{{render "cpp/namespace.end" . -}}
{{- end}}

{{- define "next/cpp/imports" -}}
#include <string>
#include <array>
#include <vector>
#include <map>
#include <unordered_map>
#include <cstdint>
{{- if .List}}
{{range .List}}
{{next . -}}
{{- end}}
{{- end}}
{{- end}}

{{- define "next/cpp/import" -}}
#include "{{.File.Name}}.h"
{{- end}}

{{- define "next/cpp/namespace.begin" -}}
{{- $namespace := .Annotations.next.cpp_namespace -}}
{{- if $namespace}}

namespace {{unquote $namespace.String}} {
{{end}}
{{- end}}

{{- define "next/cpp/namespace.end" -}}
{{- $namespace := .Annotations.next.cpp_namespace -}}
{{- if $namespace}}

} // namespace {{unquote $namespace.String}}
{{- end}}
{{- end}}

{{- define "next/cpp/forward.declarations" -}}
{{- if .Specs.Enums.List}}
// Enums forward declarations
{{- range .Specs.Enums.List}}
enum class {{.Name}};
{{- end}}
{{end -}}

{{- if .Specs.Structs.List}}
// Classes forward declarations
{{- range .Specs.Structs.List}}
class {{.Name}};
{{- end}}
{{end -}}
{{- end}}

{{- define "next/cpp/const" -}}
{{next .Doc}}static constexpr auto {{.Name}} = {{.Value}};{{next .Comment}}
{{- end}}

{{- define "next/cpp/enum" -}}
{{next .Doc}}enum class {{.Name}} : int {
{{- next .Members}}
};
{{- end}}

{{- define "next/cpp/enum.member" -}}
{{next .Doc}}{{.Name}} = {{.Value}},{{next .Comment}}
{{- end}}

{{- define "next/cpp/struct" -}}
{{next .Doc}}class {{.Name}} {
public:
    {{.Name}}() = default;
    ~{{.Name}}() = default;
    {{next .Fields}}
};
{{- end}}

{{- define "next/cpp/struct.field" -}}
{{next .Doc}}{{next .Type}} {{.Name | camelCase}};{{next .Comment}}
{{- end}}

{{- define "next/cpp/struct.field.type" -}}
{{if not (.Type.Package.In .Field.Struct.Decl.File.Package) -}}
{{$namespace := .Type.Package.Annotations.next.cpp_namespace -}}
{{if $namespace -}}
{{unquote $namespace.String}}::
{{- end -}}
{{- end -}}
{{next .Type}}
{{- end}}

{{- define "next/cpp/interface" -}}
{{next .Doc}}class {{.Name}} {
public:
    virtual ~{{.Name}}() = default;
    {{next .Methods}}
};
{{- end}}

{{- define "next/cpp/interface.method" -}}
{{next .Doc}}virtual {{next .ReturnType}} {{next .Name}}({{next .Params}}) {{if and (.Annotations.next) (.Annotations.next.const)}}const {{end}}= 0;{{next .Comment}}
{{- end}}

{{- define "next/cpp/interface.method.name" -}}
{{snakeCase .}}
{{- end}}

{{- define "next/cpp/interface.method.param.type" -}}
const {{if not (.Type.Package.In .Param.Method.Interface.Decl.File.Package) -}}
{{$namespace := .Type.Package.Annotations.next.cpp_namespace -}}
{{if $namespace -}}
{{unquote $namespace.String}}::
{{- end -}}
{{- end -}}
{{next .Type}}&
{{- end}}

{{- define "next/cpp/interface.method.return.type" -}}
{{if .Type -}}
{{if not (.Type.Package.In .Method.Interface.Decl.File.Package) -}}
{{$namespace := .Type.Package.Annotations.next.cpp_namespace -}}
{{if $namespace -}}
{{unquote $namespace.String}}::
{{- end -}}
{{- end -}}
{{next .Type}}
{{- else -}}
void
{{- end}}
{{- end}}