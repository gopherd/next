# Next Language 🚀

[中文文档](./README_CN.md)

Next is a powerful code generation language designed to create highly customized code across multiple programming languages. It leverages a flexible template system to transform high-level specifications into language-specific implementations.

## ✨ Key Features

- 🌐 Multi-language code generation from a single source
- 📝 Powerful templating system based on Go's text/template
- 🧩 Flexible customization through template inheritance and overloading
- 🏗️ Rich type system supporting structs, enums, and various data types
- 🏷️ Annotation support for metadata and customization

## 🛠️ Template System

Next uses a template system based on Go's [text/template](https://pkg.go.dev/text/template/) package, with custom enhancements for code generation. Templates in Next use the `.npl` file extension.

### 📊 Template Hierarchy and Inheritance

Next implements a three-layer template hierarchy, allowing for easy customization and overriding of default behaviors:

1. Next builtin base templates: `next/<object_type>`
2. Next builtin language-specific templates: `next/<lang>/<object_type>`
3. User-defined language-specific templates: `<lang>/<object_type>`

This hierarchy enables a powerful inheritance and overloading mechanism, similar to class inheritance in object-oriented programming.

Key `<object_type>` values include:

- `file`: Represents the entire file
- `comment`: For comments
- `doc`: For documentation
- `imports`: For import statements
- `import`: For individual import statements
- `specs`: For all specifications in a file
- `consts`: For constant specifications
- `const`: For individual constant declarations
- `enums`: For enum specifications
- `enum`: For enum declarations
- `enum.members`: For enum members collectively
- `enum.member`: For individual enum members
- `structs`: For struct specifications
- `struct`: For struct declarations
- `struct.fields`: For struct fields collectively
- `struct.field`: For individual struct fields
- `struct.field.type`: For struct field types
- `struct.field.name`: For struct field names

Additional object types include: `type.array`, `type.vector`, `type.map`, `type.enum`, `type.struct`, and various basic types.

When rendering a template, Next searches for the most specific template first (user-defined), then falls back to language-specific templates, and finally to base templates if no overrides are found.

### 🔑 Key Template Functions

Next provides several crucial template functions:

1. `next`: Automatically selects and renders the most appropriate template for a given object based on its type and the current language context.
2. `render`: Explicitly renders a named template with given data.
3. `super`: Calls the parent template in the hierarchy, allowing for extension of existing templates.
4. `head`: Outputs a generated code comment, e.g., `// Code generated by "next v0.0.1"; DO NOT EDIT.`
5. `this`: Returns the current node (file, const, enum, or struct) as specified in the template's meta information.

These functions allow for flexible template composition and overriding, making it easy to customize code generation while reusing existing logic.

## 🚀 Usage

Generate code using Next:

```bash
next [Options] [source dirs or/and files... (default .)]
```

Key options:

- `-T lang=dir|file`: Specify custom template directories or files
- `-O lang=dir`: Set output directories for generated code
- `-M lang.type=value`: Define type mappings

For full details, run `next -h`.

## 📝 Code Generation Mechanism

1. Next uses templates specified via the `-T` command-line option.
2. Templates can include meta definitions enclosed in `{{/* ... */}}` at the beginning of the file. Meta fields include:
   - `this`: Specifies the node type (file, const, enum, struct) the template applies to (default: file)
   - `path`: Defines the output file path (relative to the `-O` specified directory)
   - `skip`: Controls whether to skip code generation
   - `overwrite`: Determines whether to overwrite existing files (default: true)
3. Meta field values (except `this`) can use template expressions. For example:

```
{{/*
this: file
path: {{replace (render "java/package.name" this.Package) "." "/"}}/Constants.java
skip: {{eq 0 (len this.Specs.Consts.List)}}
*/}}
```

4. During code generation, Next traverses the syntax tree (file, const, enum, struct nodes) to find matching templates based on the `this` specification.
5. It then renders the template and outputs the generated code to the specified path.

## 📋 Example

Given a Next specification in `user.next`:

```next
@next(
    go_package = "github.com/username/repo/demo",
    cpp_namespace = "demo",
    java_package = "com.example.demo"
)
package demo;

const (
    Version = "1.0.0";
    MaxRetries = 3;
    Timeout = MaxRetries * 1000; // Constant expression
)

enum Color {
    Red = 1 << iota, // 1
    Green,           // 2
    Blue,            // 4
    Yellow,          // 8
}

struct User {
    int64 id;
    string username;
    vector<string> tags;
    map<string, int> scores;
    array<float64, 3> coordinates;
    Color favoriteColor;
}

@message(type=101)
struct LoginRequest {
    string username;
    string password;
}

@message(type=102)
struct LoginResponse {
    string token;
    User user;
}
```

Note: The `@next` annotation should be placed above the `package` declaration.

Generate C++ code with a custom template file:

```bash
next -T cpp=templates/cpp.npl -O cpp=./gen/cpp user.next
```

Generate Go code with custom templates:

```bash
next -T go=templates/go.npl -O go=./gen/go user.next
```

Generate Java code with a custom template file:

```bash
next -T java=templates/java/ -O java=./gen/java user.next
```

## 🎨 Customizing Templates

Create language-specific templates to override or extend the built-in ones. Here are examples for different languages:

### C++ Template (cpp.npl)

```
{{/*
this: file
path: {{this.Package.Name}}/{{this.Name}}.next.h
*/}}

{{- /* Overrides "next/cpp/import" */ -}}
{{- define "cpp/import" -}}
#include "../{{.File.Package.Name}}/{{.File.Name}}.next.h"
{{- end -}}

{{- /* Overrides "next/cpp/struct.fields": add method 'message_type' for each message after fields */ -}}
{{- define "cpp/struct.fields" -}}
{{- super .}}
{{- if .Struct.Annotations.message}}

    static int message_type() { return {{.Struct.Annotations.message.type}}; }
{{- end}}
{{- end -}}

{{head}}

{{next this}}
```

### Go Template (go.npl)

```
{{/*
this: file
path: {{this.Package.Name}}/{{this.Name}}.next.go
skip: {{eq "test" this.Name}}
time: 2024-08-25T23:39:46Z0800
*/}}

{{- /* Overrides "next/go/struct": add method 'MessageType' for each message after struct */ -}}
{{- define "go/struct"}}
{{- super .}}
{{- if .Annotations.message}}

func ({{.Name}}) MessageType() int { return {{.Annotations.message.type}} }
{{- end}}
{{- end -}}

{{head}}

{{next this}}
```

### Java Templates

`java/consts.npl`:

```
{{/*
this: file
path: {{replace (render "java/package.name" this.Package) "." "/"}}/Constants.java
skip: {{eq 0 (len this.Specs.Consts.List)}}
*/}}

{{- define "java/file" -}}
package {{render "java/package.name" .Package}};

{{next .Specs.Consts -}}
{{- end -}}

{{head}}

{{next this}}
```

`java/enum.npl`:

```
{{/*
this: enum
path: {{replace (render "java/package.name" this.Package) "." "/"}}/{{this.Name}}.java
*/}}

{{- define "java/enum" -}}
package {{render "java/package.name" .Package}};

{{super .}}
{{- end -}}

{{head}}

{{next this}}
```

`java/struct.npl`:

```
{{/*
this: struct
path: {{replace (render "java/package.name" this.Package) "." "/"}}/{{this.Name}}.java
*/}}

{{- /* Overrides "next/java/struct": add package and imports before struct */ -}}
{{- define "java/struct" -}}
package {{render "java/package.name" .Package}};

{{next .Decl.File.Imports}}
{{super .}}
{{- end -}}

{{- /* Overrides "next/java/struct.fields": add method 'MessageType' for each message after fields */ -}}
{{- define "java/struct.fields" -}}
{{- super .}}
{{- if .Struct.Annotations.message}}

    public static int MessageType() { return {{.Struct.Annotations.message.type}}; }
{{- end}}
{{- end -}}

{{head}}

{{next this}}
```

These examples demonstrate how to use the template hierarchy and inheritance system to customize code generation for different languages.

## 📚 Built-in Language Support

Next includes built-in templates for various languages, including C++, Go, Java, and more. These serve as a foundation for code generation and can be easily customized or extended using the template hierarchy system.

## 📖 Documentation

For detailed information on Next's syntax and features, please refer to the [language specification](docs/en/language_spec.md).

## 📄 License

Next is released under the [MIT License](LICENSE).