{{- define "next/c/file" -}}
#ifndef {{render "c/this:file.header.macro" .}}
#define {{render "c/this:file.header.macro" .}}

#include <stdint.h>
#include <string.h>

#if !defined(__cplusplus) && !defined(__bool_true_false_are_defined)
#include <stdbool.h>
#endif

#if !defined(_Bool)
typedef unsigned char _Bool;
#endif
{{next .Imports -}}
{{render "c/file:forward.declarations" . -}}
{{_}}
{{next .Decls -}}
{{_}}
#endif /* {{render "c/this:file.header.macro" .}} */
{{- end}}

{{- define "next/c/file:forward.declarations" -}}
{{- if .Decls.Enums.List}}
// Enums forward declarations
{{- range .Decls.Enums.List}}
{{- if not .Annotations.next.cpp_alias}}
{{- if .MemberType.Kind.IsInteger}}
typedef enum {{next .Type}} {{next .Type}};
{{- else}}
typedef /* enum */ struct {{next .Type}} {{next .Type}};
{{- end}}
{{- end}}
{{- end}}
{{end -}}

{{- if .Decls.Structs.List}}
// Structs forward declarations
{{- range .Decls.Structs.List}}
{{- if not .Annotations.next.cpp_alias}}
typedef struct {{next .Type}} {{next .Type}};
{{- end}}
{{- end}}
{{end -}}
{{- end}}

{{- define "next/c/decl:name" -}}
{{this.File.Annotations.next.c_package | upper}}{{.}}
{{- end}}

{{- define "next/c/this:file.header.macro" -}}
{{render "c/decl:name" this.Name | upper}}_H
{{- end}}

{{- define "next/c/doc" -}}
{{.Format "" " * " "/**\n" " */" | align}}
{{- end}}

{{- define "next/c/comment" -}}
{{- with .Text | trim -}}
{{_}} /* {{.}} */
{{- end}}
{{- end}}

{{- define "next/c/imports" -}}
{{- range .List}}
{{next .}}
{{- end}}
{{- end}}

{{- define "next/c/import" -}}
#include "{{.File.Name}}.h"
{{- end}}

{{- define "next/c/const" -}}
{{next .Doc}}#define {{next .Name}} {{.Value}}{{next .Comment}}
{{- end}}

{{- define "next/c/const.name" -}}
{{render "c/decl:name" .}}
{{- end}}

{{- define "next/c/enum" -}}
{{- if .MemberType.Kind.IsInteger -}}
{{next .Doc}}typedef enum {{next .Type}} {
    {{- next .Members}}
} {{next .Type}};
{{- else -}}
{{next .Doc}}typedef struct {{next .Type}} {
{{- if .MemberType.Kind.IsString}}
    const char* value;
{{- else if .MemberType.Kind.IsFloat}}
    double value;
{{- else}}
    {{errorf "unsupported enum member type: %s" .MemberType.Kind}}
{{- end}}
} {{next .Type}};
{{range .Members.List}}
{{next . -}}
{{end}}
{{- end -}}
{{end}}

{{- define "next/c/enum.member" -}}
{{- if .Decl.MemberType.Kind.IsInteger -}}
{{next .Doc}}{{next .Decl.Type}}_{{next .Name}} = {{.Value}},{{next .Comment}}
{{- else -}}
{{next .Doc}}#define {{next .Decl.Type}}_{{next .Name}} (({{next .Decl.Type}}){ {{- .Value -}} }){{next .Comment}}
{{- end}}
{{- end}}

{{- define "next/c/struct" -}}
{{next .Doc}}typedef struct {{next .Type}} {
    {{- next .Fields}}
} {{next .Type}};
{{- end}}

{{- define "next/c/struct.field" -}}
{{- $type := .Type.Value -}}
{{- if $type.Kind.IsArray -}}
{{next .Doc}}{{next $type.ElemType}} {{next .Name}}[{{$type.N}}];{{next .Comment}}
{{- else -}}
{{next .Doc}}{{next .Type}} {{next .Name}};{{next .Comment}}
{{- end}}
{{- end}}

{{- define "next/c/interface" -}}
{{next .Doc}}typedef struct {{next .Type}} {{next .Type}};

struct {{next .Type}} {
    void* context;
{{- range .Methods.List}}
    {{next .Result}} (*{{next .Name}})({{next $.Type}}* self{{if .Params.List}}, {{next .Params}}{{end}});
{{- end}}
};
{{- range .Methods.List}}

{{next .Doc}}static inline {{next .Result}} {{next $.Type}}_{{next .Name}}({{next $.Type}}* self{{if .Params.List}}, {{next .Params}}{{end}}) {
    return self->{{next .Name}}(self{{if .Params.List}}, {{render "c/interface.method.params:names" .Params}}{{end}});
}
{{- end}}
{{- end}}

{{- define "next/c/interface.method.name" -}}
{{snakeCase .String}}
{{- end}}

{{- define "next/c/interface.method.param" -}}
{{next .Type}} {{next .Name}}
{{- end}}

{{- define "next/c/interface.method.param.name" -}}
{{.}}
{{- end}}

{{- define "next/c/interface.method.result" -}}
{{- if .Type}}{{next .Type}}{{else}}void{{end -}}
{{- end}}

{{- define "next/c/interface.method.params" -}}
{{- range $i, $p := .List -}}
    {{if $i}}, {{end}}{{next $p -}}
{{- end -}}
{{- end}}

{{- define "next/c/interface.method.params:names" -}}
{{- range $i, $p := .List -}}
    {{if $i}}, {{end}}{{next $p.Name -}}
{{- end -}}
{{- end}}

{{- define "next/c/decl.type" -}}
{{super . | render "c/decl:name"}}
{{- end}}