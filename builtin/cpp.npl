{{- define "next/cpp/file" -}}
#pragma once

{{next .Imports -}}
{{render "cpp/file:namespace.begin" . -}}
{{render "cpp/file:forward.declarations" . -}}
{{next .Decls -}}
{{render "cpp/file:namespace.end" . -}}
{{- end}}

{{- define "next/cpp/imports" -}}
#include <any>
#include <array>
#include <cstdint>
#include <map>
#include <string>
#include <unordered_map>
#include <vector>
{{- if .List}}
{{range .List}}
{{next . -}}
{{- end}}
{{- end}}
{{- end}}

{{- define "next/cpp/import" -}}
#include "{{.File.Name}}.h"
{{- end}}

{{- define "next/cpp/used.type" -}}
{{if not (.File.Package.Contains .Type) -}}
{{$ns := .Type.Decl.File.Package.Annotations.next.cpp_package -}}
{{if $ns -}}
{{$ns}}::
{{- end -}}
{{- end -}}
{{next .Type}}
{{- end}}

{{- define "next/cpp/file:namespace.begin" -}}
{{- $ns := .Annotations.next.cpp_package -}}
{{- if $ns}}

namespace {{$ns}} {
{{end}}
{{- end}}

{{- define "next/cpp/file:namespace.end" -}}
{{- $ns := .Annotations.next.cpp_package -}}
{{- if $ns}}
} // namespace {{$ns}}
{{- end}}
{{- end}}

{{- define "next/cpp/file:forward.declarations" -}}
{{- if .Decls.Enums.List}}
// Enums forward declarations
{{- range .Decls.Enums.List}}
{{- if not .Annotations.next.cpp_alias}}
{{- if .MemberType.Kind.IsInteger}}
enum class {{next .Type}};
{{- else}}
/* enum */ class {{next .Type}};
{{- end}}
{{- end}}
{{- end}}
{{end -}}

{{- if .Decls.Structs.List}}
// Classes forward declarations
{{- range .Decls.Structs.List}}
{{- if not .Annotations.next.cpp_alias}}
class {{next .Type}};
{{- end}}
{{- end}}
{{end -}}
{{- end}}

{{- define "next/cpp/const" -}}
{{next .Doc}}static constexpr auto {{next .Name}} = {{.Value}};{{next .Comment}}
{{- end}}

{{- define "next/cpp/enum" -}}
{{- if not .Annotations.next.cpp_alias -}}
{{- if .MemberType.Kind.IsInteger -}}
{{next .Doc}}enum class {{next .Type}} : {{render "cpp/enum:member.type" .}} {
{{- next .Members}}
};
{{- else -}}
/* enum */ class {{next .Type}} {
private:
    {{render "cpp/enum:member.type" .}} value;

public:
    {{- next .Members}}

    {{next .Type}}(const {{render "cpp/enum:member.type" .}}& v) : value(v) {}

    bool operator==(const {{next .Type}}& other) const {
        return value == other.value;
    }

    operator {{render "cpp/enum:member.type" .}}() const {
        return value;
    }
};
{{- end}}
{{- end}}
{{- end}}

{{- define "next/cpp/enum.member" -}}
{{- if .Decl.MemberType.Kind.IsInteger -}}
{{next .Doc}}{{next .Name}} = {{.Value}},{{next .Comment}}
{{- else if .Decl.MemberType.Kind.IsString -}}
static inline const {{render "cpp/enum:member.type" .Decl}} {{next .Name}} = {{.Value}};
{{- else if .Decl.MemberType.Kind.IsFloat -}}
static inline constexpr {{render "cpp/enum:member.type" .Decl}} {{next .Name}} = {{.Value}};
{{- else -}}
{{errorf "unsupported enum member type: %s" .Decl.MemberType.Kind}}
{{- end}}
{{- end}}

{{- define "next/cpp/struct" -}}
{{next .Doc}}class {{next .Type}} {
public:
    {{next .Type}}() = default;
    ~{{next .Type}}() = default;
    {{next .Fields}}
};
{{- end}}

{{- define "next/cpp/struct.field" -}}
{{next .Doc}}{{next .Type}} {{next .Name | camelCase}};{{next .Comment}}
{{- end}}

{{- define "next/cpp/interface" -}}
{{next .Doc}}class {{next .Type}} {
public:
    virtual ~{{next .Type}}() = default;
    {{next .Methods}}
};
{{- end}}

{{- define "next/cpp/interface.method" -}}
{{next .Doc}}virtual {{next .Result}} {{next .Name}}({{next .Params}}) {{if not .Annotations.next.mut}}const {{end}}= 0;{{next .Comment}}
{{- end}}

{{- define "next/cpp/interface.method.name" -}}
{{snakeCase .String}}
{{- end}}

{{- define "next/cpp/interface.method.param" -}}
{{if not .Annotations.next.mut}}const {{end}}{{next .Type}}& {{next .Name}}
{{- end}}

{{- define "next/cpp/interface.method.result" -}}
{{if .Type -}}
{{next .Type}}
{{- else -}}
void
{{- end}}
{{- end}}