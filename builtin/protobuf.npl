{{/* next/protobuf/file: Generates the main structure for a Protocol Buffers file */}}
{{- define "next/protobuf/file" -}}
syntax = "proto3";

package {{this.Package.Name}};
{{render "next/protobuf/package:options" this.Package}}
{{next .Imports}}
{{next .Decls}}
{{- end}}

{{/* next/protobuf/package:options: Handles package-level options based on annotations */}}
{{- define "next/protobuf/package:options"}}
{{- if .Annotations.Contains "next" }}
{{- range $key, $value := .Annotations.next }}
    {{- if not (hasSuffix "_package" $key) -}}
        {{- continue -}}
    {{- end -}}
    {{- $lang := $key | trimSuffix "_package" -}}
    {{- if eq $lang "go" }}
option go_package = "{{$value}}";
    {{- else if eq $lang "java" }}
option java_package = "{{$value}}";
    {{- else if eq $lang "csharp" }}
option csharp_namespace = "{{$value}}";
    {{- end }}
{{- end }}
{{- end }}
{{- end }}

{{/* next/protobuf/imports: Generates import statements for Protocol Buffers */}}
{{- define "next/protobuf/imports" -}}
{{- if this.UsedKinds.Contains "any"}}
import "google/protobuf/any.proto";
{{- end}}

{{- range .List}}
{{next .}}
{{- end}}
{{- end}}

{{/* next/protobuf/import: Generates an import statement for a specific .proto file */}}
{{- define "next/protobuf/import" -}}
import "{{.File.Name}}.proto";
{{- end}}

{{/* next/protobuf/consts: Skips constant declarations as they're not directly supported in Protocol Buffers */}}
{{- define "next/protobuf/consts"}}
// Constants Skipped.
{{end -}}

{{/* next/protobuf/enum: Generates an enum declaration */}}
{{- define "next/protobuf/enum" -}}
{{- if .MemberType.Kind.IsInteger -}}
{{next .Doc}}enum {{next .Type}} {
    {{- $hasZero := false -}}
    {{- range .Members.List}}
        {{- if eq .Value.Any 0 -}}
            {{- $hasZero = true -}}
            {{- break -}}
        {{- end -}}
    {{- end}}
    {{- if not $hasZero}}
    {{next .Type | snakeCase | upper}}_UNSPECIFIED = 0;
    {{- end}}
    {{- next .Members}}
}
{{- else -}}
{{error "%s: enum type must be an integer" .Pos}}
{{- end}}
{{- end}}

{{/* next/protobuf/enum.member: Generates an enum member */}}
{{- define "next/protobuf/enum.member" -}}
{{next .Doc}}{{render "enum.member:name" .}} = {{.Value}};
{{- end}}

{{/* next/protobuf/enum.member:name: Generates the name for an enum member */}}
{{- define "next/protobuf/enum.member:name" -}}
{{.Name | snakeCase | upper}}
{{- end}}

{{/* next/protobuf/struct: Generates a message declaration */}}
{{- define "next/protobuf/struct" -}}
{{next .Doc}}message {{next .Type}} {
    {{- next .Fields}}
}
{{- end}}

{{/* next/protobuf/struct.field: Generates a field declaration within a message */}}
{{- define "next/protobuf/struct.field" -}}
{{next .Doc -}}
    {{render "struct.field:type" .}} {{render "struct.field:name" .}} = {{render "struct.field:tag" .}}{{render "struct.field:deprecated" .}};{{next .Comment}}
{{- end}}

{{/* next/protobuf/struct.field:deprecated: Adds the deprecated option to a field if necessary */}}
{{- define "next/protobuf/struct.field:deprecated" -}}
{{if .Annotations.Contains "deprecated"}} [deprecated = true]{{end}}
{{- end -}}

{{/* next/protobuf/struct.field:tag: Assigns a sequential tag number based on field index */}}
{{- define "next/protobuf/struct.field:tag" -}}
{{add .Index 1}}
{{- end -}}

{{/* next/protobuf/struct.field:type: Handles custom field type if specified */}}
{{- define "next/protobuf/struct.field:type" -}}
{{- $type := "" -}}
{{- if .Annotations.next.proto_type -}}
    {{- $type = .Annotations.next.proto_type -}}
{{- else -}}
    {{- $type = next .Type -}}
{{- end -}}

{{- if .Annotations.Contains "optional" -}}
    {{- if .Type.Kind.IsArray -}}
        {{error "%s: @optional annotation is not supported for array field" .Pos -}}
    {{- else if .Type.Kind.IsVector -}}
        {{error "%s: @optional annotation is not supported for vector field" .Pos -}}
    {{- else if .Type.Kind.IsMap -}}
        {{error "%s: @optional annotation is not supported for map field" .Pos -}}
    {{- else -}}
        {{- $type = printf "optional %s" $type -}}
    {{- end -}}
{{- end -}}

{{- $type -}}
{{- end -}}

{{/* next/protobuf/interface: Generates a service declaration */}}
{{- define "next/protobuf/interface" -}}
{{next .Doc}}service {{next .Type}} {
    {{- next .Methods}}
}
{{- end}}

{{/* next/protobuf/interface.method: Generates an RPC method declaration within a service */}}
{{- define "next/protobuf/interface.method" -}}
{{next .Doc}}rpc {{render "interface.method:name" .}} ({{render "interface.method:param.type" .}}) returns ({{next .Result}});
{{- end}}

{{/* next/protobuf/interface.method:param.type: Determines the input type for an RPC method */}}
{{- define "next/protobuf/interface.method:param.type" -}}
{{- if .Params.List -}}
{{- if eq (len .Params.List) 1 -}}
{{- next (index .Params.List 0).Type -}}
{{- else -}}
{{- render "interface.method:name" .}}Request
{{- end -}}
{{- else -}}
google.protobuf.Empty
{{- end}}
{{- end}}

{{/* next/protobuf/interface.method.result: Determines the return type for an RPC method */}}
{{- define "next/protobuf/interface.method.result" -}}
{{- if .Type -}}
{{- next .Type -}}
{{- else -}}
google.protobuf.Empty
{{- end}}
{{- end}}

{{/* next/protobuf/used.type: Generates a fully qualified type name, including package name if necessary */}}
{{- define "next/protobuf/used.type" -}}
{{- if not (.File.Package.Contains .Type) -}}
    {{.Type.File.Package.Name}}.
{{- end}}
{{- next .Type -}}
{{- end}}