{{- define "next/go/file" -}}
package {{.Package.Name}}
{{super . -}}
{{- end}}

{{- define "next/go/imports" -}}
{{render "go/imports:decl" . -}}
{{render "go/imports:unused" . -}}
{{- end}}

{{- define "next/go/imports:decl" -}}
{{ _ }}
import "strconv"
{{- if .File.Annotations.next.go_imports}}
{{- range (.File.Annotations.next.go_imports | split "," | map (trim | split "." | first | trimPrefix "*") | sort | uniq)}}
import "{{.}}"
{{- end}}
{{- end}}
{{range .TrimmedList}}
{{- if len .File.Package.Types}}
{{next .}}
{{ _ }}
{{- end}}
{{- end}}
{{- end}}

{{- define "next/go/import" -}}
import {{.File.Package.Name}} {{.File.Package.Annotations.next.go_package -}}
{{- end}}

{{- define "next/go/imports:unused" -}}
{{ _ }}
var _ = strconv.Itoa
{{- if .File.Annotations.next.go_imports}}
{{- range (.File.Annotations.next.go_imports | split "," | sort | uniq)}}
{{- $pkg := . | split "." | first}}
{{- $ptr := (hasPrefix "*" $pkg)}}
{{- $val := . | split "." | last}}
{{- $pkg = $pkg | split "/" | last}}
{{- if $ptr}}
var _ = ({{$pkg}}.{{$val}})(nil)
{{- else}}
var _ = {{$pkg}}.{{$val}}
{{- end}}
{{- end}}
{{- end}}
{{ _ }}
    {{- range $p := .TrimmedList}}
        {{- if len .File.Package.Types}}
            {{- render "go/import:unused" .}}
{{ _ }}
        {{- end}}
    {{- end}}
{{- end}}

{{- define "next/go/import:unused" -}}
var _ = (*{{.File.Package.Name}}.{{next (index (.File.Package.Types) 0)}})(nil)
{{- end}}

{{- define "next/go/type:used" -}}
{{if not (.Type.Decl.File.Package.In .File.Package) -}}
{{.Type.Decl.File.Package.Name -}}.
{{- end -}}
{{next .Type}}
{{- end}}

{{- define "next/go/const" -}}
{{next .Doc}}const {{.Name}} = {{.Value}}{{next .Comment}}
{{- end}}

{{- define "next/go/enum.type" -}}
{{if .Annotations.next.type}}{{type .Annotations.next.type}}{{else}}int{{end}}
{{- end}}

{{- define "next/go/enum" -}}
{{next .Doc}}type {{.Name}} {{render "go/enum.type" .}}

const (
{{- next .Members}}
)

func (x {{.Name}}) String() string {
    {{- $name := .Name}}
    switch x {
    {{- range .Members.List}}
    case {{$name}}_{{.Name}}:
        return "{{.Name}}"
    {{- end}}
    }
    return "{{$name}}(" + strconv.Itoa(int(x)) + ")"
}
{{- end}}

{{- define "next/go/enum.member" -}}
{{next .Doc}}{{.Decl.Name}}_{{.Name}} = {{.Value}}{{next .Comment}}
{{- end}}

{{- define "next/go/struct" -}}
{{next .Doc}}type {{.Name}} struct {
    {{- next .Fields}}
}
{{- end}}

{{- define "next/struct.field" -}}
{{next .Doc}}{{next .Name}} {{next .Type}}{{render "go/struct.field.tag" .}}{{next .Comment}}
{{- end}}

{{- define "next/go/struct.field.tag" -}}
{{/* TODO: write tag */}}
{{- end}}

{{- define "next/go/struct.field.name" -}}
{{. | pascalCase }}
{{- end}}

{{- define "next/go/interface" -}}
{{next .Doc}}type {{.Name}} interface {
    {{- next .Methods}}
}
{{- end}}

{{- define "next/go/interface.method.param" -}}
{{next .Name}} {{next .Type}}
{{- end}}

{{- define "next/go/interface.method.return" -}}
{{- if .Method.Annotations.next.error}}
{{- if .Type}} ({{next .Type}}, error)
{{- else}} error
{{- end}}
{{- else if .Type}} {{next .Type}}
{{- end}}
{{- end}}

{{- define "next/go/type:alias" -}}
{{- $alias := .Decl.Annotations.next.go_alias -}}
{{- $parts := split "." $alias -}}
{{- if eq 1 (len $parts) -}}
    {{index $parts 0}}
{{- else if eq 2 (len $parts) -}}
    {{- $pkg := (index $parts 0) -}}
    {{- $typ := (index $parts 1) -}}
    {{- $ptr := (hasPrefix "*" $pkg) -}}
    {{- $pkg = (split "/" $pkg | last)}}
    {{- if $ptr -}}*{{- end -}}
    {{$pkg}}.{{$typ}}
{{- else }}
{{- errorf "bad go_alias format: %q" $alias}}
{{- end -}}
{{- end}}