# Next 语言 🚀

[English](./README.md)

Next 是一种强大的代码生成语言,旨在跨多种编程语言创建高度定制的代码。它利用灵活的模板系统将高级规范转换为特定语言的实现。

## ✨ 主要特性

- 🌐 从单一源代码生成多语言代码
- 📝 基于 Go 的 text/template 的强大模板系统
- 🧩 通过模板继承和重载实现灵活的定制
- 🏗️ 丰富的类型系统,支持结构体、枚举和各种数据类型
- 🏷️ 支持元数据和自定义的注解

## 🛠️ 模板系统

Next 使用基于 Go 的 [text/template](https://pkg.go.dev/text/template/) 包的模板系统,并为代码生成添加了自定义增强功能。Next 中的模板使用 `.npl` 文件扩展名。

### 📊 模板层次结构和继承

Next 实现了三层模板层次结构,便于自定义和覆盖默认行为:

1. Next 内置基础模板: `next/<object_type>`
2. Next 内置语言特定模板: `next/<lang>/<object_type>`
3. 用户定义的语言特定模板: `<lang>/<object_type>`

这种层次结构实现了强大的继承和重载机制,类似于面向对象编程中的类继承。

主要的 `<object_type>` 值包括:

- `file`: 表示整个文件
- `comment`: 用于注释
- `doc`: 用于文档
- `imports`: 用于导入语句
- `import`: 用于单个导入语句
- `specs`: 用于文件中的所有规范
- `consts`: 用于常量规范
- `const`: 用于单个常量声明
- `enums`: 用于枚举规范
- `enum`: 用于枚举声明
- `enum.members`: 用于枚举成员集合
- `enum.member`: 用于单个枚举成员
- `structs`: 用于结构体规范
- `struct`: 用于结构体声明
- `struct.fields`: 用于结构体字段集合
- `struct.field`: 用于单个结构体字段
- `struct.field.type`: 用于结构体字段类型
- `struct.field.name`: 用于结构体字段名称

其他对象类型包括: `type.array`, `type.vector`, `type.map`, `type.enum`, `type.struct`, 以及各种基本类型。

渲染模板时,Next 首先搜索最具体的模板(用户定义的),然后回退到语言特定的模板,最后如果没有找到覆盖,则使用基础模板。

### 🔑 关键模板函数

Next 提供了几个关键的模板函数:

1. `next`: 根据给定对象的类型和当前语言上下文,自动选择并渲染最合适的模板。
2. `render`: 使用给定数据显式渲染命名模板。
3. `super`: 调用层次结构中的父模板,允许扩展现有模板。
4. `head`: 输出生成的代码注释,例如 `// Code generated by "next v0.0.1"; DO NOT EDIT.`
5. `this`: 返回模板元信息中指定的当前节点(文件、常量、枚举或结构体)。

这些函数允许灵活的模板组合和覆盖,使得在重用现有逻辑的同时轻松自定义代码生成。

## 🚀 使用方法

使用 Next 生成代码:

```bash
next [选项] [源目录或/和文件... (默认 .)]
```

主要选项:

- `-T lang=dir|file`: 指定自定义模板目录或文件
- `-O lang=dir`: 设置生成代码的输出目录
- `-M lang.type=value`: 定义类型映射

完整详情,请运行 `next -h`。

## 📝 代码生成机制

1. Next 使用通过 `-T` 命令行选项指定的模板。
2. 模板可以在文件开头的 `{{/* ... */}}` 中包含元定义。元字段包括:
   - `this`: 指定模板适用的节点类型(文件、常量、枚举、结构体)(默认: file)
   - `path`: 定义输出文件路径(相对于 `-O` 指定的目录)
   - `skip`: 控制是否跳过代码生成
   - `overwrite`: 确定是否覆盖现有文件(默认: true)
3. 元字段值(除 `this` 外)可以使用模板表达式。例如:

```
{{/*
this: file
path: {{replace (render "java/package.name" this.Package) "." "/"}}/Constants.java
skip: {{eq 0 (len this.Specs.Consts.List)}}
*/}}
```

4. 在代码生成过程中,Next 遍历语法树(文件、常量、枚举、结构体节点)以根据 `this` 规范找到匹配的模板。
5. 然后它渲染模板并将生成的代码输出到指定路径。

## 📋 示例

给定 `user.next` 中的 Next 规范:

```next
@next(
    go_package = "github.com/username/repo/demo",
    cpp_namespace = "demo",
    java_package = "com.example.demo"
)
package demo;

const (
    Version = "1.0.0";
    MaxRetries = 3;
    Timeout = MaxRetries * 1000; // 常量表达式
)

enum Color {
    Red = 1 << iota, // 1
    Green,           // 2
    Blue,            // 4
    Yellow,          // 8
}

struct User {
    int64 id;
    string username;
    vector<string> tags;
    map<string, int> scores;
    array<float64, 3> coordinates;
    Color favoriteColor;
}

@message(type=101)
struct LoginRequest {
    string username;
    string password;
}

@message(type=102)
struct LoginResponse {
    string token;
    User user;
}
```

注意: `@next` 注解应放在 `package` 声明上方。

使用自定义模板文件生成 C++ 代码:

```bash
next -T cpp=templates/cpp.npl -O cpp=./gen/cpp user.next
```

使用自定义模板生成 Go 代码:

```bash
next -T go=templates/go.npl -O go=./gen/go user.next
```

使用自定义模板文件生成 Java 代码:

```bash
next -T java=templates/java/ -O java=./gen/java user.next
```

## 🎨 自定义模板

创建语言特定的模板以覆盖或扩展内置模板。以下是不同语言的示例:

### C++ 模板 (cpp.npl)

```
{{/*
this: file
path: {{this.Package.Name}}/{{this.Name}}.next.h
*/}}

{{- /* 覆盖 "next/cpp/import" */ -}}
{{- define "cpp/import" -}}
#include "../{{.File.Package.Name}}/{{.File.Name}}.next.h"
{{- end -}}

{{- /* 覆盖 "next/cpp/struct.fields": 在字段后为每个消息添加 'message_type' 方法 */ -}}
{{- define "cpp/struct.fields" -}}
{{- super .}}
{{- if .Struct.Annotations.message}}

    static int message_type() { return {{.Struct.Annotations.message.type}}; }
{{- end}}
{{- end -}}

{{head}}

{{next this}}
```

### Go 模板 (go.npl)

```
{{/*
this: file
path: {{this.Package.Name}}/{{this.Name}}.next.go
skip: {{eq "test" this.Name}}
time: 2024-08-25T23:39:46Z0800
*/}}

{{- /* 覆盖 "next/go/struct": 在结构体后为每个消息添加 'MessageType' 方法 */ -}}
{{- define "go/struct"}}
{{- super .}}
{{- if .Annotations.message}}

func ({{.Name}}) MessageType() int { return {{.Annotations.message.type}} }
{{- end}}
{{- end -}}

{{head}}

{{next this}}
```

### Java 模板

`java/consts.npl`:

```
{{/*
this: file
path: {{replace (render "java/package.name" this.Package) "." "/"}}/Constants.java
skip: {{eq 0 (len this.Specs.Consts.List)}}
*/}}

{{- define "java/file" -}}
package {{render "java/package.name" .Package}};

{{next .Specs.Consts -}}
{{- end -}}

{{head}}

{{next this}}
```

`java/enum.npl`:

```
{{/*
this: enum
path: {{replace (render "java/package.name" this.Package) "." "/"}}/{{this.Name}}.java
*/}}

{{- define "java/enum" -}}
package {{render "java/package.name" .Package}};

{{super .}}
{{- end -}}

{{head}}

{{next this}}
```

`java/struct.npl`:

```
{{/*
this: struct
path: {{replace (render "java/package.name" this.Package) "." "/"}}/{{this.Name}}.java
*/}}

{{- /* 覆盖 "next/java/struct": 在结构体之前添加包和导入 */ -}}
{{- define "java/struct" -}}
package {{render "java/package.name" .Package}};

{{next .Decl.File.Imports}}
{{super .}}
{{- end -}}

{{- /* 覆盖 "next/java/struct.fields": 在字段后为每个消息添加 'MessageType' 方法 */ -}}
{{- define "java/struct.fields" -}}
{{- super .}}
{{- if .Struct.Annotations.message}}

    public static int MessageType() { return {{.Struct.Annotations.message.type}}; }
{{- end}}
{{- end -}}

{{head}}

{{next this}}
```

这些示例演示了如何使用模板层次结构和继承系统来为不同语言自定义代码生成。

## 📚 内置语言支持

Next 包含多种语言的内置模板,包括 C++、Go、Java 等。这些模板作为代码生成的基础,可以使用模板层次结构系统轻松自定义或扩展。

## 📖 文档

有关 Next 语法和功能的详细信息,请参阅[语言规范](docs/zh/language_spec.md)。

## 📄 许可证

Next 根据 [MIT 许可证](LICENSE) 发布。