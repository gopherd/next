# CommandLine {#user-content-CommandLine}
## Command {#user-content-CommandLine_Command}
### version {#user-content-CommandLine_Command_version}

`version` command prints the version of the next compiler. It prints the version of the next compiler and exits the program.

Example:
```sh
next version
```

Output:
```
next v0.0.4(main: 51864a35de7890d63bfd8acecdb62d20372ca963) built at 2024/09/27T22:58:21+0800 by go1.23.0
```

## Flag {#user-content-CommandLine_Flag}
### -D {#user-content-CommandLine_Flag_-D}

`-D` represents the custom environment variables for code generation. The value is a map of environment variable names and their optional values.

Example:

```sh
next -D VERSION=2.1 -D DEBUG -D NAME=myapp ...
```

```npl
{{env.NAME}}
{{env.VERSION}}
```

Output:

```
myapp
2.1
```

### -M {#user-content-CommandLine_Flag_-M}

`-M` represents the language-specific type mappings and features.

Example:

```sh
next -M cpp.vector="std::vector<%T%>" \
     -M java.array="ArrayList<%T%>" \
     -M go.map="map[%K%]%V%" \
     -M python.ext=.py \
     -M ruby.comment="# %T%" \
     ...
```

### -O {#user-content-CommandLine_Flag_-O}

`-O` represents the output directories for generated code of each target language.

Example:

```sh
next -O go=./output/go -O ts=./output/ts ...
```

:::tip

The `{{meta.path}}` is relative to the output directory.

:::

### -T {#user-content-CommandLine_Flag_-T}

`-T` represents the custom template directories or files for each target language. You can specify multiple templates for a single language.

Example:

```sh
next -T go=./templates/go \
     -T go=./templates/go_extra.npl \
     -T python=./templates/python.npl \
     ...
```

### -X {#user-content-CommandLine_Flag_-X}

`-X` represents the custom annotation solver programs for code generation. Annotation solvers are executed in a separate process to solve annotations. All annotations are passed to the solver program via stdin and stdout. The built-in annotation `next` is reserved for the Next compiler.

Example:

```sh
next -X message="message-type-allocator message-types.json" ...
```

:::tip

In the example above, the `message-type-allocator` is a custom annotation solver program that reads the message types from the `message-types.json` file and rewrite the message types to the `message-types.json` file.

:::

### -header {#user-content-CommandLine_Flag_-header}

`-header` represents the header comment for generated code. The value is a string that represents the header comment for generated code. The default value is an empty string, which means default header comment is used.

Example:

```sh
next -header "Code generated by Next; DO NOT EDIT." ...
```

:::note

Do not add the comment characters like `//` or `/* */` in the header. Next will add them automatically based on the target language comment style.

:::

### -test {#user-content-CommandLine_Flag_-test}

`-test` represents the test mode of the compiler. The default value is **false**, which means the compiler is not in test mode. The value **true** enables the test mode, which is used for validating but not generating code.

Example:

```sh
next -test ...
```

### -v {#user-content-CommandLine_Flag_-v}

`-v` represents the verbosity level of the compiler. The default value is **0**, which only shows error messages. The value **1** shows debug messages, and **2** shows trace messages. Usually, the trace message is used for debugging the compiler itself. Levels **1** (debug) and above enable execution of:

- **print** and **printf** in Next source files (.next).
- **debug** in Next template files (.npl).

Example:

```sh
next -v 1 ...
```

