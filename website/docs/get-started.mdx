---
slug: /
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import Admonition from "@theme/Admonition";

import CodeBlock from "@theme/CodeBlock";

import NextDemoSource from "!!raw-loader!@site/testdata/next/demo.next";
import CppDemoNplSource from "!!raw-loader!@site/testdata/templates/cpp/file.cpp.npl";
import CppDemoHeaderSource from "!!raw-loader!@site/testdata/gen/cpp/demo.h";
import JavaDemoConstantsNplSource from "!!raw-loader!@site/testdata/templates/java/constants.java.npl";
import JavaDemoEnumNplSource from "!!raw-loader!@site/testdata/templates/java/enum.java.npl";
import JavaDemoInterfaceNplSource from "!!raw-loader!@site/testdata/templates/java/interface.java.npl";
import JavaDemoStructNplSource from "!!raw-loader!@site/testdata/templates/java/struct.java.npl";
import JavaDemoColorSource from "!!raw-loader!@site/testdata/gen/java/com/example/demo/Color.java";
import JavaDemoConstantsSource from "!!raw-loader!@site/testdata/gen/java/com/example/demo/Constants.java";
import JavaDemoContractSource from "!!raw-loader!@site/testdata/gen/java/com/example/demo/Contract.java";
import JavaDemoHTTPClientSource from "!!raw-loader!@site/testdata/gen/java/com/example/demo/HTTPClient.java";
import JavaDemoHTTPServerSource from "!!raw-loader!@site/testdata/gen/java/com/example/demo/HTTPServer.java";
import JavaDemoLoginRequestSource from "!!raw-loader!@site/testdata/gen/java/com/example/demo/LoginRequest.java";
import JavaDemoLoginResponseSource from "!!raw-loader!@site/testdata/gen/java/com/example/demo/LoginResponse.java";
import JavaDemoMathConstantsSource from "!!raw-loader!@site/testdata/gen/java/com/example/demo/MathConstants.java";
import JavaDemoOperatingSystemSource from "!!raw-loader!@site/testdata/gen/java/com/example/demo/OperatingSystem.java";
import JavaDemoReaderSource from "!!raw-loader!@site/testdata/gen/java/com/example/demo/Reader.java";
import JavaDemoUint128Source from "!!raw-loader!@site/testdata/gen/java/com/example/demo/Uint128.java";
import JavaDemoUserSource from "!!raw-loader!@site/testdata/gen/java/com/example/demo/User.java";

# Get Started

## Introduction

Next is an advanced Interface Definition Language (IDL) designed for efficient and flexible code generation across multiple programming languages.

Next allows developers to define constants, enums, structures, interfaces, and more in a language-agnostic manner. It then uses a powerful template system to generate code for various target languages, making it an ideal choice for projects that need to maintain consistency across different programming environments.

## How It Works

1. **Define Once**: Write your data structures, enums, and interfaces in Next.
2. **Annotate**: Use annotations to provide language-specific details or additional metadata.
3. **Template**: Create or use existing templates for your target languages.
4. **Generate**: Use the Next compiler to generate code for multiple languages from your single definition.

```mermaid
%%{init: {
  'theme': 'base',
  'themeVariables': {
    'primaryColor': '#6c5ce7',
    'primaryTextColor': '#ffffff',
    'primaryBorderColor': '#5b4cc4',
    'lineColor': '#a29bfe',
    'secondaryColor': '#81ecec',
    'tertiaryColor': '#fab1a0'
  }
}}%%
flowchart TD
    A([Next Definitions]):::input --> B[Next Compiler]
    G([Templates]):::input --> B
    H([Type Mappings]):::input --> B
    I([Annotations]):::input --> B
    B --> C([Go Code]):::output
    B --> D([C++ Code]):::output
    B --> E([Java Code]):::output
    B --> F([Other Languages]):::output

    classDef default fill:#f0f0f0,stroke:#333,stroke-width:1px
    classDef input fill:#81ecec,stroke:#0984e3,stroke-width:2px,color:#2d3436
    classDef compiler fill:#6c5ce7,stroke:#5b4cc4,stroke-width:2px,color:#ffffff
    classDef output fill:#fab1a0,stroke:#e17055,stroke-width:2px,color:#2d3436

    class B compiler
    linkStyle default stroke:#a29bfe,stroke-width:2px
```

## Installation

<Tabs
  defaultValue="unix"
  values={[
    { label: 'Unix-like', value: 'unix' },
    { label: 'Windows', value: 'windows' },
    { label: 'Source Code', value: 'source' },
  ]}>

  <TabItem value="unix">
  To install Next on Unix-like systems (`Linux`, `macOS`, `Git Bash for Windows`, etc.), you can use the following command:

```sh
curl -fsSL https://getnext.sh | sh
```

This script will download and install the latest version of Next on your system.

  </TabItem>

  <TabItem value="windows">
  For Windows users, follow these steps:

1. Download the installation package from [Downloads](/docs/downloads) for windows.
2. Extract the downloaded ZIP file.
3. Right-click on the `install.bat` file in the extracted folder.
4. Select "Run as administrator" to execute the installation script.

This will install the Next on your Windows system.

  </TabItem>

  <TabItem value="source">
  To install Next from source, use the following command:

```sh
go install github.com/next/next@latest
```

Make sure you have [Go](https://go.dev) `1.23+` installed on your system before running this command.

  </TabItem>
</Tabs>

After installing `next`, run `next version` to show the version informarion

```sh
next version
```

:::tip
Run `next -h` to show the command usage.

```sh
next -h
```

:::

<details>
<summary>Install Editor Extensions</summary>

<Tabs
  defaultValue="vscode"
  values={[
    { label: 'VSCode', value: 'vscode' },
  ]}>
  <TabItem value="vscode">
  Install Visual Studio Code Extension for Next from [marketplace](https://marketplace.visualstudio.com/items?itemName=nextlangorg.nextlang).

This extension provides syntax highlighting, and other helpful features for Next development in Visual Studio Code. You can install it directly from the provided link or search for `next lang` in the Visual Studio Code Extensions marketplace.

  </TabItem>
</Tabs>
</details>

## Write a Next source file

First of all, You need write a Next source file which has extension `.next` used to define constants, enums, structures and interfaces. Here is an example Next file:

<details open>
<summary>demo.next</summary>

<CodeBlock language="next" showLineNumbers>
  {NextDemoSource}
</CodeBlock>
</details>

:::tip
See [Language Specification](/docs/language_spec) for details about `next` language specification.
:::

## Write a Next template file

Then, write a Next template file which has extension `.npl` used to conctrol how to generate code for specified language. Here is an example template file used to generate `c++` code.

<CodeBlock language="npl" title="file.cpp.npl">
  {CppDemoNplSource}
</CodeBlock>

- **`{{head}}`**: Generate a header like this: `// Code generated by "next v0.0.4"; DO NOT EDIT.`
- **`{{next this}}`**: Generate `this` declaration. By default, `this` is a file if the `meta/this` not specified.

:::tip
See [API/Context/meta](/docs/api/latest/context#user-content-Context_meta) for details about `meta`.
:::

## Generate code

Finally, run `next` command to generate code using `demo.next` and `file.cpp.npl`:

```sh
next -T cpp=file.cpp.npl -O cpp=gen/cpp/ demo.next
```

<details>
<summary>Output</summary>

<CodeBlock language="cpp" title="demo.h" showLineNumbers>{CppDemoHeaderSource}</CodeBlock>
</details>

## How to generate multi-language codes?

It's easy to generate many other langauge codes by writing template files. Here is an example to generate `java` code.

<Tabs
  defaultValue="constants"
  values={[
    { label: 'constants.java.npl', value: 'constants' },
    { label: 'enum.java.npl', value: 'enum' },
    { label: 'struct.java.npl', value: 'struct' },
    { label: 'interface.java.npl', value: 'interface' },
  ]}>

    <TabItem value="constants">
        <CodeBlock language="npl">{JavaDemoConstantsNplSource}</CodeBlock>

        This template file is used to generate all constants in a file `Constants.java` which define a `Constants` class to holds all constants of a package.
        We add some metadata and override `next/java/package` by defining `java/package`. We need define `meta/this` with `package`.

        <details>
            <summary>Output</summary>

            <Tabs
            defaultValue="Constants"
            values={[
                { label: 'Constants.java', value: 'Constants' },
            ]}>
                <TabItem value="Constants">
                    <CodeBlock language="java">{JavaDemoConstantsSource}</CodeBlock>
                </TabItem>
            </Tabs>
        </details>
    </TabItem>

    <TabItem value="enum">
        <CodeBlock language="npl">{JavaDemoEnumNplSource}</CodeBlock>

        This template file is used to generate java file for each `enum` declaration. We need define `meta/this` with `enum`.

        <details>
            <summary>Output</summary>

            <Tabs
            defaultValue="Color"
            values={[
                { label: 'Color.java', value: 'Color' },
                { label: 'MathConstants.java', value: 'MathConstants' },
                { label: 'OperatingSystem.java', value: 'OperatingSystem' },
            ]}>
                <TabItem value="Color">
                <CodeBlock language="java">{JavaDemoColorSource}</CodeBlock>
                </TabItem>
                <TabItem value="MathConstants">
                <CodeBlock language="java">{JavaDemoMathConstantsSource}</CodeBlock>
                </TabItem>
                <TabItem value="OperatingSystem">
                <CodeBlock language="java">{JavaDemoOperatingSystemSource}</CodeBlock>
                </TabItem>
            </Tabs>
        </details>
    </TabItem>

    <TabItem value="struct">
        <CodeBlock language="npl">{JavaDemoStructNplSource}</CodeBlock>

        This template file is used to generate java file for each `struct` declaration. We need define `meta/this` with `struct`.

        <details>
            <summary>Output</summary>

            <Tabs
            defaultValue="Contract"
            values={[
                { label: 'Contract.java', value: 'Contract' },
                { label: 'LoginRequest.java', value: 'LoginRequest' },
                { label: 'LoginResponse.java', value: 'LoginResponse' },
                { label: 'Uint128.java', value: 'Uint128' },
                { label: 'User.java', value: 'User' },
            ]}>
                <TabItem value="Contract">
                    <CodeBlock language="java">{JavaDemoContractSource}</CodeBlock>
                </TabItem>
                <TabItem value="LoginRequest">
                    <CodeBlock language="java">{JavaDemoLoginRequestSource}</CodeBlock>
                </TabItem>
                <TabItem value="LoginResponse">
                    <CodeBlock language="java">{JavaDemoLoginResponseSource}</CodeBlock>
                </TabItem>
                <TabItem value="Uint128">
                    <CodeBlock language="java">{JavaDemoUint128Source}</CodeBlock>
                </TabItem>
                <TabItem value="User">
                    <CodeBlock language="java">{JavaDemoUserSource}</CodeBlock>
                </TabItem>
            </Tabs>
        </details>
    </TabItem>

    <TabItem value="interface">
        <CodeBlock language="npl">{JavaDemoInterfaceNplSource}</CodeBlock>

        This template file is used to generate java file for each `interface` declaration. We need define `meta/this` with `interface`.

        <details>
            <summary>Output</summary>

            <Tabs
            defaultValue="HTTPClient"
            values={[
                { label: 'HTTPClient.java', value: 'HTTPClient' },
                { label: 'HTTPServer.java', value: 'HTTPServer' },
                { label: 'Reader.java', value: 'Reader' },
            ]}>
                <TabItem value="HTTPClient">
                    <CodeBlock language="java">{JavaDemoHTTPClientSource}</CodeBlock>
                </TabItem>
                <TabItem value="HTTPServer">
                    <CodeBlock language="java">{JavaDemoHTTPServerSource}</CodeBlock>
                </TabItem>
                <TabItem value="Reader">
                    <CodeBlock language="java">{JavaDemoReaderSource}</CodeBlock>
                </TabItem>
            </Tabs>
        </details>
    </TabItem>

</Tabs>

:::note
To generate `java` code, we need write templates for each declaration types: `enum`, `struct`, `interface`. Specially, we write a template file to generate all constants in a single file `Constants.java`.
:::

Run `next` to generate multi-language codes as following(we assume `*.java.npl` files placed in dir `java`):

```sh
next -T cpp=file.cpp.npl -O cpp=gen/cpp/ -T java=java/ -O java=gen/java/ demo.next
```

When you have write templates for other langauges, you can generate codes like this:

```sh
next \
    -O c=gen/c -T c=templates/c \
    -O cpp=gen/cpp -T cpp=templates/cpp \
    -O csharp=gen/csharp -T csharp=templates/csharp \
    -O go=gen/go -T go=templates/go \
    -O java=gen/java -T java=templates/java \
    -O js=gen/js -T js=templates/js \
    -O lua=gen/lua -T lua=templates/lua \
    -O protobuf=gen/protobuf -T protobuf=templates/protobuf \
    -O python=gen/python -T python=templates/python \
    -O php=gen/php -T php=templates/php \
    -O rust=gen/rust/src -T rust=templates/rust \
    -O swift=gen/swift -T swift=templates/swift \
    -O ts=gen/ts -T ts=templates/ts \
    -M "c.vector=void*" -M "c.map=void*" \
    next/source/dir/ # or source files
```

## Builtin supported langauges

Usually, to generate code for a language, you need a [Map](/docs/api/latest/map) file and at least one template file.
Currently, Next has created some builtin `map` files and base templates. See [builtin](https://github.com/gopherd/next/tree/main/builtin) for more informarion.

Here is an example for langauge `c++`:

<Tabs
  defaultValue="map"
  values={[
    { label: "cpp.map", value: "map" },
    { label: "cpp.npl", value: "npl" },
  ]}
>
  <TabItem value="map">

```map
ext=.h
comment=// %T%

int=int
int8=int8_t
int16=int16_t
int32=int32_t
int64=int64_t
float32=float
float64=double
bool=bool
string=std::string
byte=unsigned char
bytes=std::vector<unsigned char>
any=std::any
map=std::unordered_map<%K%, %V%>
vector=std::vector<%T%>
array=std::array<%T%, %N%>
```

</TabItem>

<TabItem value="npl">

```npl
{{/* next/cpp/file: Generates the main structure for a C++ header file */}}
{{- define "next/cpp/file" -}}
#pragma once

{{next .Imports -}}
{{render "file:namespace.begin" . -}}
{{render "file:forward.declarations" . -}}
{{next .Decls -}}
{{render "file:namespace.end" . -}}
{{- end}}

{{/* next/cpp/imports: Generates standard C++ include statements and user-defined imports */}}
{{- define "next/cpp/imports" -}}
#include <any>
#include <array>
#include <cstdint>
#include <map>
#include <string>
#include <unordered_map>
#include <vector>
{{- if .List}}
{{range .List}}
{{next . -}}
{{- end}}
{{- end}}
{{- end}}

{{/* next/cpp/import: Generates an include statement for a user-defined header */}}
{{- define "next/cpp/import" -}}
#include "{{.Target.Name}}.h"
{{- end}}

{{/* next/cpp/used.type: Generates a fully qualified type name, including namespace if necessary */}}
{{- define "next/cpp/used.type" -}}
{{if not (.File.Package.Contains .Type) -}}
{{$ns := .Type.Decl.File.Package.Annotations.next.cpp_package -}}
{{if $ns -}}
{{$ns}}::
{{- end -}}
{{- end -}}
{{next .Type}}
{{- end}}

{{/* next/cpp/file:namespace.begin: Begins a namespace block if a C++ package is specified */}}
{{- define "next/cpp/file:namespace.begin" -}}
{{- $ns := .Annotations.next.cpp_package -}}
{{- if $ns}}

namespace {{$ns}} {
{{end}}
{{- end}}

{{/* next/cpp/file:namespace.end: Ends a namespace block if a C++ package is specified */}}
{{- define "next/cpp/file:namespace.end" -}}
{{- $ns := .Annotations.next.cpp_package -}}
{{- if $ns}}
} // namespace {{$ns}}
{{- end}}
{{- end}}

{{/* next/cpp/file:forward.declarations: Generates forward declarations for enums and classes */}}
{{- define "next/cpp/file:forward.declarations" -}}
{{- if .Decls.Enums.List -}}
// Enums forward declarations
{{- range .Decls.Enums.List}}
{{- if not .Annotations.next.cpp_alias}}
{{- if .MemberType.Kind.IsInteger}}
enum class {{next .Type}};
{{- else}}
/_ enum _/ class {{next .Type}};
{{- end}}
{{- end}}
{{- end}}

{{end -}}

{{- if .Decls.Structs.List -}}
// Classes forward declarations
{{- range .Decls.Structs.List}}
{{- if not .Annotations.next.cpp_alias}}
class {{next .Type}};
{{- end}}
{{- end}}

{{end}}
{{- end}}

{{/* next/cpp/const: Generates a constant declaration */}}
{{- define "next/cpp/const" -}}
{{next .Doc}}inline constexpr auto {{render "const:name" .}} = {{.Value}};{{next .Comment}}
{{- end}}

{{/* next/cpp/enum: Generates an enum class declaration */}}
{{- define "next/cpp/enum" -}}
{{- if not .Annotations.next.cpp_alias -}}
{{- if .MemberType.Kind.IsInteger -}}
{{next .Doc}}enum class {{next .Type}} : {{render "enum:member.type" .}} {
{{- next .Members}}
};
{{- else -}}
/_ enum _/ class {{next .Type}} {
private:
{{render "enum:member.type" .}} value;

public:
{{- next .Members}}

    {{next .Type}}(const {{render "enum:member.type" .}}& v) : value(v) {}

    bool operator==(const {{next .Type}}& other) const {
        return value == other.value;
    }

    operator {{render "enum:member.type" .}}() const {
        return value;
    }

};
{{- end}}
{{- end}}
{{- end}}

{{/* next/cpp/enum.member: Generates an enum member */}}
{{- define "next/cpp/enum.member" -}}
{{- if .Decl.MemberType.Kind.IsInteger -}}
{{next .Doc}}{{render "enum.member:name" .}} = {{.Value}},{{next .Comment}}
{{- else if .Decl.MemberType.Kind.IsString -}}
static inline const {{render "enum:member.type" .Decl}} {{render "enum.member:name" .}} = {{.Value}};
{{- else if .Decl.MemberType.Kind.IsFloat -}}
static inline constexpr {{render "enum:member.type" .Decl}} {{render "enum.member:name" .}} = {{.Value}};
{{- else -}}
{{error "%s: unsupported enum member type: %s" .Decl.Pos .Decl.MemberType.Kind}}
{{- end}}
{{- end}}

{{/* next/cpp/struct: Generates a class declaration (struct in C++ is typically implemented as a class) */}}
{{- define "next/cpp/struct" -}}
{{next .Doc}}class {{next .Type}} {
public:
{{next .Type}}() = default;
~{{next .Type}}() = default;
{{next .Fields}}
};
{{- end}}

{{/* next/cpp/struct.field: Generates a class member variable declaration */}}
{{- define "next/cpp/struct.field" -}}
{{- $zero := render "type:zero" .Type -}}
{{- if $zero -}}
{{- $zero = printf " = {%s}" $zero -}}
{{- end -}}
{{next .Doc}}{{next .Type}} {{render "struct.field:name" . | camelCase}}{{$zero}};{{next .Comment}}
{{- end}}

{{/* next/cpp/interface: Generates an abstract base class declaration (interface in C++ is typically implemented as an abstract class) */}}
{{- define "next/cpp/interface" -}}
{{next .Doc}}class {{next .Type}} {
public:
virtual ~{{next .Type}}() = default;
{{next .Methods}}
};
{{- end}}

{{/* next/cpp/interface.method: Generates a pure virtual method declaration */}}
{{- define "next/cpp/interface.method" -}}
{{next .Doc}}virtual {{next .Result}} {{render "interface.method:name" .}}({{next .Params}}) {{if not .Annotations.next.mut}}const {{end}}= 0;{{next .Comment}}
{{- end}}

{{/* next/cpp/interface.method:name: Generates the name for an interface method */}}
{{- define "next/cpp/interface.method:name" -}}
{{snakeCase .Name}}
{{- end}}

{{/* next/cpp/interface.method.param: Generates a parameter for an interface method */}}
{{- define "next/cpp/interface.method.param" -}}
{{if not .Annotations.next.mut}}const {{end}}{{next .Type}}& {{render "interface.method.param:name" .}}
{{- end}}

{{/* next/cpp/interface.method.result: Generates the return type for an interface method */}}
{{- define "next/cpp/interface.method.result" -}}
{{if .Type -}}
{{next .Type}}
{{- else -}}
void
{{- end}}
{{- end}}

{{/* next/cpp/type:zero: Generates a zero-initializer for a type */}}
{{- define "next/cpp/type:zero" -}}
{{- if .Kind.IsArray -}}
{{- super .Actual.ElemType -}}
{{- else if .Kind.IsEnum -}}
{{- next . -}}({{render "type:zero" .Actual.Decl.MemberType -}})
{{- else -}}
{{- super . -}}
{{- end -}}
{{- end}}
```

</TabItem>
</Tabs>
