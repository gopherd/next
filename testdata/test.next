// Package declaration

@next(
    go_package="github.com/nextlang/test/comprehensive",
    cpp_namespace = "nextlang::test"
)
package comprehensive_test;

// Constants
const (
    ServerName = "Comprehensive Test Server";
    Version = "1.0.0";
    MaxConnections = 1000;
    Pi = 3.14159265358979323846;
    MaxInt64 = 9223372036854775807;  // 2^63 - 1
    MinInt64 = -9223372036854775808; // -2^63
)

// Output and assert constants
println("Constants:");
printf("ServerName = %s\n", ServerName);
assert(ServerName == "Comprehensive Test Server", "ServerName mismatch");
printf("Version = %s\n", Version);
assert(Version == "1.0.0", "Version mismatch");
printf("MaxConnections = %d\n", MaxConnections);
assert(MaxConnections == 1000, "MaxConnections mismatch");
printf("Pi = %f\n", Pi);
assert(Pi > 3.14 && Pi < 3.15, "Pi value out of expected range");
printf("MaxInt64 = %d\n", MaxInt64);
assert(MaxInt64 == 9223372036854775807, "MaxInt64 mismatch");
printf("MinInt64 = %d\n", MinInt64);
assert(MinInt64 == -9223372036854775808, "MinInt64 mismatch");

// Constants with complex expressions
const (
    A = 1;
    B = A + 2;
    C = B * 3;
    D = (C + 5) / 2;
    E = D << 2;
    F = E | (1 << 10);
    G = F & 0xFFFF;
    H = G ^ 0x1234;
    I = H + 1.618;  // Approximation of golden ratio
    J = I / 120;    // 120 is 5!
)

// Output and assert complex constants
println("\nComplex Constants:");
printf("A = %d\n", A);
assert(A == 1, "A mismatch");
printf("B = %d\n", B);
assert(B == 3, "B mismatch");
printf("C = %d\n", C);
assert(C == 9, "C mismatch");
printf("D = %d\n", D);
assert(D == 7, "D mismatch");
printf("E = %d\n", E);
assert(E == 28, "E mismatch");
printf("F = %d\n", F);
assert(F == 1052, "F mismatch");
printf("G = %d\n", G);
assert(G == 1052, "G mismatch");
printf("H = %d\n", H);
assert(H == 5672, "H mismatch");
printf("I = %f\n", I);
assert(I > 5673.0 && I < 5674.0, "I value out of expected range");
printf("J = %f\n", J);
assert(J > 47.28 && J < 47.29, "J value out of expected range");

// Constants with function calls
const (
    StringLength = len("Hello, World!");
    MinValue = min(A, B, C, D, E);
    MaxValue = max(F, G, H, int(I), int(J));
)
println("int(I) =", int(I));
println("int(J) =", int(J));

// Output and assert function call constants
println("\nFunction Call Constants:");
printf("StringLength = %d\n", StringLength);
assert(StringLength == 13, "StringLength mismatch");
printf("MinValue = %d\n", MinValue);
assert(MinValue == 1, "MinValue mismatch");
printf("MaxValue = %d\n", MaxValue);
assert(MaxValue == 5673, "MaxValue mismatch");

// Enum with iota
enum Color {
    Red = 1 << iota, // 1
    Green,           // 2
    Blue,            // 4
    Alpha,           // 8
    Yellow = Red | Green, // 3
    Cyan = Green | Blue,  // 6
    Magenta = Red | Blue, // 5
    White = Red | Green | Blue, // 7
}

// Output and assert Color enum
println("\nColor Enum:");
printf("Red = %d\n", Color.Red);
assert(Color.Red == 1, "Color.Red mismatch");
printf("Green = %d\n", Color.Green);
assert(Color.Green == 2, "Color.Green mismatch");
printf("Blue = %d\n", Color.Blue);
assert(Color.Blue == 4, "Color.Blue mismatch");
printf("Alpha = %d\n", Color.Alpha);
assert(Color.Alpha == 8, "Color.Alpha mismatch");
printf("Yellow = %d\n", Color.Yellow);
assert(Color.Yellow == 3, "Color.Yellow mismatch");
printf("Cyan = %d\n", Color.Cyan);
assert(Color.Cyan == 6, "Color.Cyan mismatch");
printf("Magenta = %d\n", Color.Magenta);
assert(Color.Magenta == 5, "Color.Magenta mismatch");
printf("White = %d\n", Color.White);
assert(Color.White == 7, "Color.White mismatch");

// Enum with complex iota usage
enum FilePermission {
    None = 0,
    Execute = 1 << iota, // 1
    Write,               // 2
    Read,                // 4
    
    UserRead = Read << (3 * iota), // 4
    UserWrite,                     // 4<<3 = 32
    UserExecute,                   // 4<<6 = 256
    
    GroupRead, // 4<<9 = 2048
    GroupWrite, // 4<<12 = 16384
    GroupExecute, // 4<<15 = 131072
    
    OthersRead, // 4<<18 = 1048576
    OthersWrite, // 4<<21 = 8388608
    OthersExecute, // 4<<24 = 67108864
    
    // 4|32|256|2048|16384|131072|1048576|8388608|67108864
    // 4 + 32 + 256 + 2048 + 16384 + 131072 + 1048576 + 8388608 + 67108864
    All = UserRead | UserWrite | UserExecute | 
          GroupRead | GroupWrite | GroupExecute | 
          OthersRead | OthersWrite | OthersExecute,
}

// Output and assert FilePermission enum
println("\nFilePermission Enum:");
printf("None = %d\n", FilePermission.None);
assert(FilePermission.None == 0, "FilePermission.None mismatch");
printf("Execute = %d\n", FilePermission.Execute);
assert(FilePermission.Execute == 1, "FilePermission.Execute mismatch");
printf("Write = %d\n", FilePermission.Write);
assert(FilePermission.Write == 2, "FilePermission.Write mismatch");
printf("Read = %d\n", FilePermission.Read);
assert(FilePermission.Read == 4, "FilePermission.Read mismatch");
printf("UserRead = %d\n", FilePermission.UserRead);
assert(FilePermission.UserRead == 4, "FilePermission.UserRead mismatch");
printf("UserWrite = %d\n", FilePermission.UserWrite);
assert(FilePermission.UserWrite == 32, "FilePermission.UserWrite mismatch");
printf("UserExecute = %d\n", FilePermission.UserExecute);
assert(FilePermission.UserExecute == 256, "FilePermission.UserExecute mismatch");
printf("GroupRead = %d\n", FilePermission.GroupRead);
assert(FilePermission.GroupRead == 2048, "FilePermission.GroupRead mismatch");
printf("GroupWrite = %d\n", FilePermission.GroupWrite);
assert(FilePermission.GroupWrite == 16384, "FilePermission.GroupWrite mismatch");
printf("GroupExecute = %d\n", FilePermission.GroupExecute);
assert(FilePermission.GroupExecute == 131072, "FilePermission.GroupExecute mismatch");
printf("OthersRead = %d\n", FilePermission.OthersRead);
assert(FilePermission.OthersRead == 1048576, "FilePermission.OthersRead mismatch");
printf("OthersWrite = %d\n", FilePermission.OthersWrite);
assert(FilePermission.OthersWrite == 8388608, "FilePermission.OthersWrite mismatch");
printf("OthersExecute = %d\n", FilePermission.OthersExecute);
assert(FilePermission.OthersExecute == 67108864, "FilePermission.OthersExecute mismatch");
printf("All = %d\n", FilePermission.All);
assert(FilePermission.All == (4 + 32 + 256 + 2048 + 16384 + 131072 + 1048576 + 8388608 + 67108864), "FilePermission.All mismatch");

// Enum group
enum (
    Day {
        Monday = 1 << iota,
        Tuesday,
        Wednesday,
        Thursday,
        Friday,
        Saturday,
        Sunday,
        
        Weekday = Monday | Tuesday | Wednesday | Thursday | Friday,
        Weekend = Saturday | Sunday,
    }
    
    Month {
        January = 1 << iota,
        February,
        March,
        April,
        May,
        June,
        July,
        August,
        September,
        October,
        November,
        December,
        
        Q1 = January | February | March,
        Q2 = April | May | June,
        Q3 = July | August | September,
        Q4 = October | November | December,
    }
)

// Output and assert Day enum
println("\nDay Enum:");
printf("Monday = %d\n", Day.Monday);
assert(Day.Monday == 1, "Day.Monday mismatch");
printf("Tuesday = %d\n", Day.Tuesday);
assert(Day.Tuesday == 2, "Day.Tuesday mismatch");
printf("Wednesday = %d\n", Day.Wednesday);
assert(Day.Wednesday == 4, "Day.Wednesday mismatch");
printf("Thursday = %d\n", Day.Thursday);
assert(Day.Thursday == 8, "Day.Thursday mismatch");
printf("Friday = %d\n", Day.Friday);
assert(Day.Friday == 16, "Day.Friday mismatch");
printf("Saturday = %d\n", Day.Saturday);
assert(Day.Saturday == 32, "Day.Saturday mismatch");
printf("Sunday = %d\n", Day.Sunday);
assert(Day.Sunday == 64, "Day.Sunday mismatch");
printf("Weekday = %d\n", Day.Weekday);
assert(Day.Weekday == 31, "Day.Weekday mismatch");
printf("Weekend = %d\n", Day.Weekend);
assert(Day.Weekend == 96, "Day.Weekend mismatch");

// Output and assert Month enum
println("\nMonth Enum:");
printf("January = %d\n", Month.January);
assert(Month.January == 1, "Month.January mismatch");
printf("February = %d\n", Month.February);
assert(Month.February == 2, "Month.February mismatch");
printf("March = %d\n", Month.March);
assert(Month.March == 4, "Month.March mismatch");
printf("April = %d\n", Month.April);
assert(Month.April == 8, "Month.April mismatch");
printf("May = %d\n", Month.May);
assert(Month.May == 16, "Month.May mismatch");
printf("June = %d\n", Month.June);
assert(Month.June == 32, "Month.June mismatch");
printf("July = %d\n", Month.July);
assert(Month.July == 64, "Month.July mismatch");
printf("August = %d\n", Month.August);
assert(Month.August == 128, "Month.August mismatch");
printf("September = %d\n", Month.September);
assert(Month.September == 256, "Month.September mismatch");
printf("October = %d\n", Month.October);
assert(Month.October == 512, "Month.October mismatch");
printf("November = %d\n", Month.November);
assert(Month.November == 1024, "Month.November mismatch");
printf("December = %d\n", Month.December);
assert(Month.December == 2048, "Month.December mismatch");
printf("Q1 = %d\n", Month.Q1);
assert(Month.Q1 == 7, "Month.Q1 mismatch");
printf("Q2 = %d\n", Month.Q2);
assert(Month.Q2 == 56, "Month.Q2 mismatch");
printf("Q3 = %d\n", Month.Q3);
assert(Month.Q3 == 448, "Month.Q3 mismatch");
printf("Q4 = %d\n", Month.Q4);
assert(Month.Q4 == 3584, "Month.Q4 mismatch");

// Struct types
struct Point2D {
    float64 x;
    float64 y;
}

struct Point3D {
    Point2D point;
    float64 z;
}

struct Rectangle {
    Point2D topLeft;
    Point2D bottomRight;
}

// Struct with various field types
struct ComplexStruct {
    bool flag;
    int8 tinyInt;
    int16 smallInt;
    int32 mediumInt;
    int64 bigInt;
    int defaultInt;
    float32 singlePrecision;
    float64 doublePrecision;
    string text;
    byte singleByte;
    bytes byteArray;
    array<int, 5> fixedArray;
    vector<string> dynamicArray;
    map<string, int> dictionary;
}

// Struct group
struct (
    User {
        int64 id;
        string username;
        string email;
        Day preferredDay;
        Month birthMonth;
    }
    
    @json(name = "UserProfile")
    UserProfile {
        User user;
        string firstName;
        string lastName;
        int age;
        vector<string> interests;
    }
)

// Protocol types
protocol LoginRequest {
    @key
    string username;
    @sensitive
    string password;
    string deviceId;
    @optional
    string twoFactorToken;
}

protocol LoginResponse {
    bool success;
    @json(omitempty)
    string errorMessage;
    @json(name = "auth_token")
    string authenticationToken;
    User user;
}

// Protocol group
protocol (
    GenericRequest {
        string requestId;
        int64 timestamp;
    }
    
    GenericResponse {
        string requestId;
        int64 timestamp;
        bool success;
        @json(omitempty)
        string errorCode;
        @json(omitempty)
        string errorMessage;
    }
)

// Test cases for iota
enum IotatestEnum {
    A = iota,     // 0
    B,            // 1
    C = iota * 2, // 0
    D,            // 2
    E = iota * iota,  // 0
    F,                // 1
    G = iota + C,     // 0
}

// Output and assert IotatestEnum
println("\nIotatestEnum:");
printf("A = %d\n", IotatestEnum.A);
assert(IotatestEnum.A == 0, "IotatestEnum.A mismatch");
printf("B = %d\n", IotatestEnum.B);
assert(IotatestEnum.B == 1, "IotatestEnum.B mismatch");
printf("C = %d\n", IotatestEnum.C);
assert(IotatestEnum.C == 0, "IotatestEnum.C mismatch");
printf("D = %d\n", IotatestEnum.D);
assert(IotatestEnum.D == 2, "IotatestEnum.D mismatch");
printf("E = %d\n", IotatestEnum.E);
assert(IotatestEnum.E == 0, "IotatestEnum.E mismatch");
printf("F = %d\n", IotatestEnum.F);
assert(IotatestEnum.F == 1, "IotatestEnum.F mismatch");
printf("G = %d\n", IotatestEnum.G);
assert(IotatestEnum.G == 0, "IotatestEnum.G mismatch");

// Constants using built-in functions
const (
    IntFromBool = int(true);
    IntFromFloat = int(3.14);
    FloatFromInt = float(42);
    FloatFromBool = float(false);
    BoolFromInt = bool(1);
    BoolFromString = bool("true");
    
    FormattedString1 = sprint("The answer is ", 42);
    FormattedString2 = sprintf("Pi is approximately %.2f", Pi);
    FormattedString3 = sprintln("Hello", "World");
)

// Output and assert built-in function constants
println("\nBuilt-in Function Constants:");
printf("IntFromBool = %d\n", IntFromBool);
assert(IntFromBool == 1, "IntFromBool mismatch");
printf("IntFromFloat = %d\n", IntFromFloat);
assert(IntFromFloat == 3, "IntFromFloat mismatch");
printf("FloatFromInt = %f\n", FloatFromInt);
assert(FloatFromInt == 42.0, "FloatFromInt mismatch");
printf("FloatFromBool = %f\n", FloatFromBool);
assert(FloatFromBool == 0.0, "FloatFromBool mismatch");
printf("BoolFromInt = %v\n", BoolFromInt);
assert(BoolFromInt == true, "BoolFromInt mismatch");
printf("BoolFromString = %v\n", BoolFromString);
assert(BoolFromString == true, "BoolFromString mismatch");

printf("FormattedString1 = %s\n", FormattedString1);
assert(FormattedString1 == "The answer is 42", "FormattedString1 mismatch");
printf("FormattedString2 = %s\n", FormattedString2);
assert(FormattedString2 == "Pi is approximately 3.14", "FormattedString2 mismatch");
printf("FormattedString3 = %s\n", FormattedString3);
assert(FormattedString3 == "Hello World\n", "FormattedString3 mismatch");

// Constants for testing complex expressions and bitwise operations
const (
    Complex1 = (A + B) * (C - D) / (E + F) & (G | H) ^ int(I);
    Complex2 = min(max(A, B, C), min(D, E, F)) + abs(G - H) * len(sprint(I, J));
    Complex3 = (Day.Weekday);
    Complex4 = (Day.Weekday &^ Day.Weekend);
    Complex5 = Color.Red | (FilePermission.UserRead & FilePermission.GroupWrite) | (Day.Weekday &^ Day.Weekend);
)

// Output and assert complex expression constants
println("\nComplex Expression Constants:");
printf("Complex1 = %d\n", Complex1);
assert(Complex1 == 5673, "Complex1 mismatch");
printf("Complex2 = %d\n", Complex2);
assert(Complex2 == 78547, "Complex2 mismatch");
printf("Complex3 = %d\n", Complex3);
assert(Complex3 == 31, "Complex3 mismatch");
printf("Complex4 = %d\n", Complex4);
assert(Complex4 == 31, "Complex4 mismatch");
printf("Complex5 = %d\n", Complex5);
assert(Complex5 == 31, "Complex5 mismatch");

// Test for potential circular references (commented out to avoid errors)
//const (
//    Circular1 = Circular2 + 1;
//    Circular2 = Circular3 + 2;
//    Circular3 = Circular1 + 3;
//)

// Print statements for final output
println("\nComprehensive test completed successfully!");
println("All assertions passed.");

// Final assertion to ensure all tests have run
assert(true, "This assertion should always pass if we reach this point");

assert_eq(1, 2);